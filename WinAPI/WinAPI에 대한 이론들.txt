1. 변수 명명법

윈도우즈에서는 워낙 많은 변수가 사용되므로 대체로 변수 이름을
길게 쓰며 되도록 보기 좋게(= 읽기 쉽게) 하기 위해 대문자와 소문자를
적당히 혼합하여 사용한다. 특히 자주 사용하는 변수 형식에 대해서는 
관습적으로 정해진 접두어를 많이 사용한다.

cb 	Count of Bytes	바이트 수
dw	Double world	부호없는 long형 정수
h	handle		윈도우 비트맵, 파일등의 핸들
sz	Null Terminater	NULL 종료 문자열
cs	Character	문자형
a	Array		배열
w	Word		부호없는 정수형
i	Integer		정수형
p,lp	long Pointer	포인터형
b	Bool		논리형

이외에도 윈도우즈에서는 사용자 정의 데이터형들이 많이 있다.
이 데이터 형은 windows.h헤더 파일에 typdef로 선언되어 있으며
마치 표준 데이터형처럼 사용한다.

BYTE	unsgined char형
CHAR	char형
WORD	unsigned short형
DWORD	unsigned long형
LONG	long과 동일
BOOL	정수형이며 TRUE, FALSE 중 한값을 가진다.

특별한 이유가 없는 한 unsgined short 같은 C 언어의 타입을 쓰는 것보다
WORD같은 중간 타입을 사용하다가 호환성 확보를 할때 WORD의 정의만 바꿔주면
매우 유용하다.


2. 핸들?

핸들이란 구체적인 어떤 대상에 붙여진 번호이며 문법적으로는 32비트(또는 64비트)의
정수값이다. 

윈도우즈에서는 여러가지 종류의 핸들이 사용되고 있으며 만들어진 윈도우에는
윈도우 핸들(hWnd)을 붙여 번호로 DC에 대해서도 핸들을 사용하고 논리적 펜,
브러시에도 핸들을 붙여 관리한다.

왜 이렇게 핸들을 많이 사용하는가?
 - 문자열보다 정수를 사용하는 것이 속도가 훨씬 빠르고 간편하기 때문

핸들의 특징 - 숙지해놓을것
1. 핸들은 정수값이며 대부분의 경우 32비트 값이다.
 - 핸들을 사용하는 목적은 오로지 구분을 위한 것이므로 핸들끼리 중복되지 않아야 하며
   이런 목적으로는 정수형이 가장 적합함.

2. 핸들은 운영체제가 발급하며 사용자는 쓰기만 한다. 
 - 예를 들어 우리가 윈도우를 만들거나 파일을 열경우 운영체제가 자동으로 핸들을
   붙이고 그 값을 리턴한다. 사용자는 이 값들을 보관해 두었다가 해당 윈도우나 파일을
   다시 참조할 때 사용한다.

3. 같은 종류의 핸들끼리는 절대로 중복된 값을 가지지 않는다.
 - 만약 이렇게 된다면 대상을 구분하는 본래의 목적을 할 수 없을것.

4. 핸들은 정수형이므로 값을 가지겠으나 그 값이 무엇인지는 몰라도 상관없다.
 - 핸들은 크고 작음의 성질을 가지는 숫자가 아니라 단순한 표식일 뿐이다.

윈도우즈에서 핸들은 예외없이 접두어 H로 시작되며 핸들값을 저장하기 위해 
별도의 데이터형까지 정의해 두고 있다.
HWND, HPEN, HBRUSH, HDC등이 핸들을 담기 위한 데이터 형들이다.


3. 비트 OR 연산자

사용자는 작업을 학 위해 함수를 호출하는데, 이때 함수에게 작업의 내용을 전달하는
인수가 같이 건네지는데 인수에는 작업의 목적과 방법을 지정하는 정보가 포함된다.

윈도우즈 API함수들도 마찬가지로 작업에 대한 세부 정보를 인수로 전달받는다.
그런데 전달 가능한 옵션이 여러 개 있을 경우 필요한 옵션수만큼 인수를 전달 받는
것이 아니라 하나의 인수에 복수개의 옵션을 묶어 전달하는데 이 때 사용되는 것이 바로
비트 OR 연산자(|)다.

예를 들어 함수에 수평 정렬을 하는 옵션, 개행 여부, 수직정렬 여부, 여러줄 출력 등의
다양한 옵션들이 있는데 이 많은 옵션들이 OR 연산자로 연결되어 딱 하나의 인수로 전달된다.
예로 DT_CENTER | DT_BOTTOM | DT_WORDBREAK 등과 같이 하면 세가지 옵션을
하나의 인수로 전달 한 것이다.

한 인수에 이렇게 여러 가지 옵션을 같이 전달할 수 있는 이유는 각 옵션이
비트 별로 배정(2의 거듭승)되어 있기 때문이다.

DT_CENTER 	= 0 0 0 0 0 0 0 1
DT_BOTTOM 	= 0 0 0 0 1 0 0 0
DT_WORDBREAK	= 0 0 0 1 0 0 0 0
OR 연산자 ->	= 0 0 0 1 1 0 0 1


4. 유니코드

유니코드는 16비트의 단일한 값으로 지구상의 모든 문자를 표현할 수 있는 
문자코드 체계이다.

유니코드를 지원하려면 문자형이나 문자열에 대해 C언어의 타입을 바로 쓰지말고
유니코드 설정에 따라 변경되는 중간 타입을 사용해야 한다.

char	 	TCHAR
char* 		LPSTR
const char * 	LPCTSTR

TCHAR은 C의 기본 타입 중 하나인 char과 일단 같지만 유니코드로 컴파일할 때는
wchar_t 타입이 된다. wchar_t는 unsigned short로 정의되어 있다.

TCHAR은 다음과 같이 선언되어있는데,

#ifdef UNICODE
typedef wchar_t TCHAR;
#else
typedef char TCHAR;
#endif

이로 인해 유니코드로 바꿀 때 일일이 소스를 뜯어 고친후 다시 컴파일할 필요 없이 
중간 타입을 사용한 소스는 프로젝트 설정에 따라 소스도 같이 바뀌게 된다.

문자열을 다루는 함수들도 C의 표준 함수를 쓰기보다 유니코드를 인식하는 함수를
사용하자. sprintf -> wsprintf를 제외하면 표준함수의 이름앞에 l자가 붙는다는것만
다르며 운영체제가 제공하는 함수이므로 별도의 용량을 차지하지 않는다.


