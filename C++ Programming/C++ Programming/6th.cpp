// 클래스의 기본적인 연산들

// 클래스 자신을 초기화 - 생성자
// 메모리 등 리소스를 정리하기 - 소멸자
// 클래스 자신을 복사하기 - 복사 생성자, 복사 할당 연산자

// 생성자 - 객체가 선언될 때 실행됨
// 클래스와 이름값이 같은 리턴 값이 없는 상태로 선언됨
// 생성자는 보통 public으로 선언, private에 있으면 외부에서 생성자를 호출할수 없음
// - 가끔 싱글턴 패턴과 같이 private에 넣기도 함

// 생성자가 호출 될 때
// 객체를 만들 때, 메모리를 할당 할 때
// 생성자들의 오버로드도 가능
// 함수 오버로드와 동일

// 생성자는 만들지 않더라도 C++에서 자동으로 디폴트 생성자를 만들어 줌
// 그러나 생성자를 하나라도 만들 경우 디폴트 생성자는 만들어지지 않는다
// - person(int a, int b)만 만들 경우 person()생성자는 만들어지지 않음

// 클래스의 각 멤버는 생성자로 초기화 되어야 함
// 단 const 멤버 변수의 경우 선언 될 때 초기화가 되어야 함

class Person {
private :
	double a;
	double b;
public :
	Person() {
		// cout << "생성자 호출";
	}
};

int main() {
	Person p1;
	Person p2 = new Person();
}

// 출력 
// 생성자 호출
// 생성자 호출

// 소멸자
// 생성자가 객체를 초기화 하듯 반대로 객체를 더 이상 사용하지 않을 때 정리하는 코드도 필요
// 소멸자는 객체가 더 이상 필요 없을 때 호출 됨
// 소멸자 선언 방법 : 생성자 앞에 ~를 붙임

// 소멸자가 호출 될 때
// delete Person;
// if (true){ 
//   Person p; 
// }
// 이곳에서 호출

// 소멸은 같은 범위일경우 먼저 생성된 객체가 나중에 소멸됨 (스택 구조)


// this 포인터
// this 포인터는 클래스 안에서 사용 가능한 특별한 포인터
// 인스턴스 는 독자적인 멤버를 가지나 클래스 공통의 멤버 함수와 매칭 됨
// 이 때 멤버 함수가 인스턴스를 구별하는 방법이 this포인터

// 멤버 함수 내에서 명칭의 우선 순위는 
// 지역변수 > 멤버 변수 > 전역 변수 순으로 높다

class Person {
private:
	double a;
	double b;
public : 
	Person();
	Person(double _a, double _b) : a(_a), b(_b) {}
	
	void setA(double a) { this->a = a; };
};