// c++은 크로스 플랫폼용 개발을 위해 선택 할 수 있는 언어. 이것만은 기억해 달라.
// 비주얼 스튜디오의 중심언어

// C++은 오래된 언어이기 때문에 젊은 개발자가 잡기 어렵다.

// VS 2013에서 메뉴를 다 대문자라 썼다 욕먹음ㅋㅋㅋㅋㅋ
// VS 2015 에서는 설치할 언어를 선택 할 수 있음. 워낙 큰지라...
// VS 2015는 XP를 지원한다. 한국에서 많이 쓰기때문에. 발표자들 외국인인데 국제망신ㅋㅋㅋㅋㅋㅋㅋㅋㅋ
// VS 2015는 에코 시스템을 개선하였고 계속 개선하고 있다. 터치 스크린 기능 지원, 깃, 등등...
// 우리는 3개월 내에 피드백을 적용시켜 새 버전을 계속 내보내고 있다.

// 긴 코드 줄은 특수기능을 스마트태그를 활용해보자
// raw string liternal

// 퀵액션으로 할 수 있는 행동들을 볼 수 있고, 선택 할 수 있다.(퀵 액션은 오른쪽에서 나옴)

// Rename all symboll references accurately
// 함수 이름 바꾸기. 찾아바꾸기를 하면 잘못 바뀔 수 있다.
// 위의 기능들을 활용하면 문법에 맞게 바꿀수 있고, 프리뷰를 통해서 바뀌는 곳을 볼수도 있다.
// 함수선택 -> 오른쪽 클릭 -> 리네임

// Generic Lambdas
// 람다 식을 함수로 바꿔버릴 수 있다.

// Send smile, Send frown으로 피드백을 보내주셈
// 우린 너님들의 피드백이 정말 중요함

// 디버깅시 자동적으로 프로파일러들이 등장하기 시작
// cpu사용량이라던가 코어를 얼마나 쓴다던가 실시간으로 활용 하는 것을 볼 수 있다!
// 우리는 디버깅쪽에 굉장히 많은 변화를 도입함

// C++ Exception 역시 제공되기 시작

// 디버깅하면서 함수를 지나면, 몇초가 지나는지 실시간으로 보여 줌

// 리팩토링에 관한 기능이 추가됨
// 이제 파일을 따로 열어도 칼라코딩이 된다
// 또한 그 단일파일을 기반으로 프로젝트를 만들 수 있다.
// - 싱글 파일 브라우징

// 다른 플랫폼에서도 자동으로 변환 되도록 설정해줌.
// ex) wstring을 다른 기종마다 전부 자동으로 변환되어 적용시켜줌

// C++ 14와 11의 기능들이 추가됨
// 제네릭 람다식 14
// Init - captures 14
// constexpr
// noexept
// char16_t, char31_t
// 그 이외에도 다양한 기능, C++11과 C++14의 표준을 지키려하고 있고 몇개는 아직 못지켰다ㅠㅠ

// 문자열에서 유니코드도 지원. u"";
// C++ 17의 표준도 넣으려 하고 있다.

// Clang/C2라는 코드 제네레이터가 다음달에 나올거. 기대하셈
// 이게 머시나면 다른 언어의 코드를 위노우에서 사용하게 해주는거.
// ex) 오브젝트C나 다른 언어들 -> 윈도우 애플리케이션

// 컴파일시간이 존나 줄어듬 내부적으로 코드 최적화까지 시켜줌
// 너가 실수로 비효율적인 코드를 짜면 컴파일할때 어느정도 보정해준다

// 다음달의 첫 업데이트가 나오니 기대점 3개월 마다 한번 나올거임

// 앞으로 우린 여러가지 생각중인데 병렬형태의 에디터로 만들어
// 리눅스나 다른 개발환경에서도 C++을 개발 할 수 있게 해볼거.





// NDK를 사용하는 앱은 생각보다 많다.
// top 50의 앱들 중 80퍼센트가 NDK를 조금이라도 쓰고 있다.

// C/C++로 안드로이드 프레임워크 확장을 위한것이 아닌
// NDK만으로 안드로이드 앱 개발이 가능
// 데스크탑 앱을 모바일앱으로 옮기기 위해 필요하기도 하다
// 최소한의 자바 문법만 사용하면 안드로이드 앱을 개발 할 수 있다.

// Platform != OS
// 플랫폼은 운영체제의 기반이 되는 기술의 집합체지 OS 그 자체가 아니다.

// 멀티플랫폼과 크로스플랫폼의 차이
// 멀티는 두가지 이상에서 정상적으로 "동작"하는것,크로스는 "사용"되는것

// VS 2015에서는 바로 설치해서 개발이 가능하다!
// 주의! 용량 존나 많음 다 설치하면 대략 30기가ㄷㄷ

// 개발사 입상이라면 어떨까? 다수의 플랫폼에서 작동하는게 제일 좋겠지?
// 하지만 이러면 개발자를 많이 써야하고, 돈도 증가ㅠㅠ
// 범용 크로스플랫폼을 지원하는 라이브러리로 개발하는 방법이 있지만,
// 이러면 고객의 기기에서 최적화가 덜 지원 될 수 도 있고 이는 곧 불만으로 이어짐

// visual studio emulator for android
// 이제 졷같은 이클립스 안써도 된다! 만세!
// 이거는 빠르지만 설치가 조금 힘들고, 가상OS나 Azure에서는 불가...
// 프로 에디션 이상에서만 가능ㄷㄷ 홈에디션 이런거 안됨
// 네트워크는 DHCP, 자동 DNS나 gateway설정이 필요
// 바이오스에서 가상화 지원되나 확인해야함
// Hyper-V를 하려면 다음의 기능이 필요
// Hardware-assisted virtualzation
// SLAT
// DEP
// 에뮬은 보통 메모리를 2기가정도(요새 모바일폰 정도) 잡아먹음. 메모리가 8기가는 되야함.

// 윈도우 홈에디션은 키만 바꾸면 자동으로 업그레이드 할 수 있음

// 기존 안드 에뮬(SDK)는 존나 버벅대고 암걸렸음
// VS 2015의 에뮬을 보고 암이 나았습니다
// 추가기능도 쉽게, 많이 지원하니 써보셈
// 심지어 베터리 테스트, 카메라 테스트도 가능

// ARM은 안됨요 -> AVD Manager로 ARM Emulator을 실행해줘야함
// 근데 USB 디버깅이 안됨ㅠㅠ 언젠가 고쳐주겠져

// 네이티브 앱의 실행 흐름

// ANativeActivity_onCreate
//     |
// android_app_create - 여기서 스레드를 만듬
//     |
// android_app_entry
//     |
// android_main -> Alooper_pollAll -> 이벤트 존재 인식 -> process -> 출력 engine_draw_frame()
//     |
// android_app_detroy





// 비주얼 스튜디오를 통한 디버깅 꿀팁들

// 2015에 새로운 기능들이 많이 나옴
// 가장 눈에 띄고 새로운, 중요한 기능인 프로파일링의 등장
// F5 = 디버깅 + 프로파일링!
// 여러가지 통합된 정보가 뜬다. 이슈, 메모리 사용량, CPU점유율 등...

// 이제 코드에서 시간 측정이 가능!
// 커뮤니티 에디션에서도 가능하며, 지원 언어는 C#,VB,C++

// 중단점을 활용하면 부분마다 얼마나 시간이 걸리나 자세히 볼 수 있다

// 메모리 사용량에 가면 메모리 스냅샷을 뜰 수 있다.

// 옆의 Private bytes란? 다른 것과 공유되지 않는 메모리로서 상당히 크게 보인다.
// 반면에 아래의 메모리 사용량에서는 힙의 메모리의 사용량만이 나옴

// 그 외에 메모리의 다른 내용들을 볼수도 있다.

// 뷰 힙으로 들어가면 무엇이 메모리를 얼마나 먹고있나 볼 수 있다
// 거기에 항목을 클릭하면 소스코드의 어느부분인지도 디버깅이 된다.

// 디버그 다이얼로그 써보셈 메모리 릭기능 있음
// 예전에는 필 수 였지만 지금은 이게 VS에도 간단히 나옴

// 인텔리트레이스
// 잡기 어려운 버그를 잡는데 좋음
// 실행을 녹화한다면? Historical Debugging





// 모던 C++

// 모던 C++이란? C++ 11/14를 말함

// 어디를 수정해줘야 할까?
// 전처리기
// 리소스 관리
// 함수
// 타입, 반복문... 등등

// 조건부 컴파일
// 편리하긴 한데 많이 쓸수록 복잡해지며 이해하기도 힘들고 유지보수도 어렵다.

// 타입에 따른 조건부 컴파일은 함수 템플릿으로 개선
// 그러나 조건부 컴파일을 사용해야 하는 경우 - 
// 디버그모드냐 아니냐, 컴파일러, 플랫폼, os나 32비트 64비트를 구분지어야 할때
// 써야 된다면, 코드를 단순화 하라.


// 매크로
// 변수대신 사용하는 매크로와 함수 대신 사용하는 매크로로 나눔
// 그러나 수많은 문제를 일으키는 장본인
// 원인? 컴파일러가 타입에 대한 정보를 갖기전에 계산됨
// 필요 이상으로 많이 사용

// 변수 대신 사용하는 매크로
// 문제! - 예제 코드 참조하기
// 변수형 매크로는 열거체로 대체!
// 단 열거체도 완벽하지는 않다. 열거체 안의 요소들은 묵시적으로 int로 처리되기 때문. 이 타입은 정의할수가 없다.
// 또한 전역변수로 선언된다. 범위적용이 이상한것.
// 이를 위해 enum class를 사용하자!
// 열거체를 굳이 int로 바꿔야 할때는 static_cast를 쓰자!

// 함수 대신 사용하는 매크로
// 인라인 함수로 바꿔서 사용하자.
// 읽기 쉽고, 유지보수도 쉽고, 디버깅하기도 쉽다.
// 성능에 다른 오버헤드도 없다.


// 리소스 관리
// RAII
// 자원 획득은 초기화다
// 객체의 생성에 맞춰 메모리와 시스템 리소스를 자동으로 할당, 소멸에 맞춰 해제해 준다
// -> 생성자에서 할당하고 소멸자에서 해제해준다

// 그러나 동적할당애서는 이게 제대로 먹질 않음
// 이를 위해 스마트 포인터가 등장
// 명시적으로 해제할 필요가 없으며, 버그도 적고, 자동청소, 자동 초기화, 효율성은 당연히 증가

// 스마터포인터는 객체의 소유권을 복사할 수 있는 포인터와 없는 포인터 두개가 있음. 유니크, 쉐어.
// 소유권을 복사한다는 것은 여러 스마트 포인터 객체가 같은 포인터 객체를 가리킬 수 있음.
// 그 반대는 하나의 포인터 객체만 가리킬 수 있음.

// 소유권을 하나만 가질수있는 포인터에 다른 객체가 소유권을 가지려 할경우, 원래 소유권을 가졌던
// 스마트 포인터 객체의 소유권이 해제됨. 

// 얘네는 nullptr로 초기화 가능함

// 리소스 관리는 스마트 포인터로
// RAII를 사용하자!
// - 읽고, 쓰고, 유지보수하기 쉬우며 자원관리에 대한 걱정을 할 필요가 없다. 
// 기왕이면 스마트 포인터로!


// 함수
// 함수 -> 람다식으로 대체
// 람다식에 대해 다시보고 싶으면 지난 12월에 우리 그룹에서 열었던 세미나를 보자

// 람다식
// 게시자, 인자, 반환 타입, 함수의 몸통으로 
// 람다식에는 여러 형태가 있음
// 짧고, 간결하고, 행사코드 없이 깔끔하게 작성 가능
// 수십줄의 코드를 1~2줄을 간추릴 수 있다.
// 단 반복적으로 사용하는 함수가 아닐 때 주로 사용하자.


// auto 키워드
// 컴파일 할때 타입을 추론해 어떤 타입인지 결정한다.
// 추론이 불가능할 경우, 오류가 발생한다.

// 범위 기반 for문

// C++ 표준위원회는 포인터를 권장하지 않으며, 스마트 포인터의 사용을 권고하고 있음.